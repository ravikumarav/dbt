# Stubs for logbook.handlers (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from logbook.base import ContextObject
from typing import Any, Optional

DEFAULT_FORMAT_STRING: Any
SYSLOG_FORMAT_STRING: Any
NTLOG_FORMAT_STRING: Any
TEST_FORMAT_STRING: Any
MAIL_FORMAT_STRING: Any
MAIL_RELATED_FORMAT_STRING: Any
SYSLOG_PORT: int
REGTYPE: Any

def create_syshandler(application_name: Any, level: Any = ...): ...

class _HandlerType(type):
    def __new__(cls, name: Any, bases: Any, d: Any): ...

class Handler(ContextObject):
    stack_manager: Any = ...
    blackhole: bool = ...
    level: Any = ...
    formatter: Any = ...
    filter: Any = ...
    bubble: Any = ...
    def __init__(
        self, level: Any = ..., filter: Optional[Any] = ..., bubble: bool = ...
    ) -> None: ...
    level_name: Any = ...
    def format(self, record: Any): ...
    def should_handle(self, record: Any): ...
    def handle(self, record: Any): ...
    def emit(self, record: Any) -> None: ...
    def emit_batch(self, records: Any, reason: Any) -> None: ...
    def close(self) -> None: ...
    def handle_error(self, record: Any, exc_info: Any) -> None: ...

class NullHandler(Handler):
    blackhole: bool = ...
    def __init__(self, level: Any = ..., filter: Optional[Any] = ...) -> None: ...

class WrapperHandler(Handler):
    handler: Any = ...
    def __init__(self, handler: Any) -> None: ...
    def __getattr__(self, name: Any): ...
    def __setattr__(self, name: Any, value: Any): ...

class StringFormatter:
    format_string: Any = ...
    def __init__(self, format_string: Any) -> None: ...
    def format_record(self, record: Any, handler: Any): ...
    def format_exception(self, record: Any): ...
    def __call__(self, record: Any, handler: Any): ...

class StringFormatterHandlerMixin:
    default_format_string: Any = ...
    formatter_class: Any = ...
    format_string: Any = ...
    def __init__(self, format_string: Any) -> None: ...

class HashingHandlerMixin:
    def hash_record_raw(self, record: Any): ...
    def hash_record(self, record: Any): ...

class LimitingHandlerMixin(HashingHandlerMixin):
    record_limit: Any = ...
    record_delta: Any = ...
    def __init__(self, record_limit: Any, record_delta: Any) -> None: ...
    def check_delivery(self, record: Any): ...

class StreamHandler(Handler, StringFormatterHandlerMixin):
    encoding: Any = ...
    lock: Any = ...
    stream: Any = ...
    def __init__(
        self,
        stream: Any,
        level: Any = ...,
        format_string: Optional[Any] = ...,
        encoding: Optional[Any] = ...,
        filter: Optional[Any] = ...,
        bubble: bool = ...,
    ) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: Any, exc_value: Any, tb: Any): ...
    def ensure_stream_is_open(self) -> None: ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    def encode(self, msg: Any): ...
    def write(self, item: Any) -> None: ...
    def emit(self, record: Any) -> None: ...
    def should_flush(self): ...

class FileHandler(StreamHandler):
    stream: Any = ...
    def __init__(
        self,
        filename: Any,
        mode: str = ...,
        encoding: Optional[Any] = ...,
        level: Any = ...,
        format_string: Optional[Any] = ...,
        delay: bool = ...,
        filter: Optional[Any] = ...,
        bubble: bool = ...,
    ) -> None: ...
    def write(self, item: Any) -> None: ...
    def close(self) -> None: ...
    def encode(self, record: Any): ...
    def ensure_stream_is_open(self) -> None: ...

class GZIPCompressionHandler(FileHandler):
    def __init__(
        self,
        filename: Any,
        encoding: Optional[Any] = ...,
        level: Any = ...,
        format_string: Optional[Any] = ...,
        delay: bool = ...,
        filter: Optional[Any] = ...,
        bubble: bool = ...,
        compression_quality: int = ...,
    ) -> None: ...
    def write(self, item: Any) -> None: ...
    def should_flush(self): ...

class BrotliCompressionHandler(FileHandler):
    def __init__(
        self,
        filename: Any,
        encoding: Optional[Any] = ...,
        level: Any = ...,
        format_string: Optional[Any] = ...,
        delay: bool = ...,
        filter: Optional[Any] = ...,
        bubble: bool = ...,
        compression_window_size: Any = ...,
        compression_quality: int = ...,
    ) -> None: ...
    def write(self, item: Any) -> None: ...
    def should_flush(self): ...
    def flush(self) -> None: ...
    def close(self) -> None: ...

class MonitoringFileHandler(FileHandler):
    def __init__(
        self,
        filename: Any,
        mode: str = ...,
        encoding: str = ...,
        level: Any = ...,
        format_string: Optional[Any] = ...,
        delay: bool = ...,
        filter: Optional[Any] = ...,
        bubble: bool = ...,
    ) -> None: ...
    stream: Any = ...
    def emit(self, record: Any) -> None: ...

class StderrHandler(StreamHandler):
    def __init__(
        self,
        level: Any = ...,
        format_string: Optional[Any] = ...,
        filter: Optional[Any] = ...,
        bubble: bool = ...,
    ) -> None: ...
    @property
    def stream(self): ...

class RotatingFileHandler(FileHandler):
    max_size: Any = ...
    backup_count: Any = ...
    def __init__(
        self,
        filename: Any,
        mode: str = ...,
        encoding: str = ...,
        level: Any = ...,
        format_string: Optional[Any] = ...,
        delay: bool = ...,
        max_size: Any = ...,
        backup_count: int = ...,
        filter: Optional[Any] = ...,
        bubble: bool = ...,
    ) -> None: ...
    def should_rollover(self, record: Any, bytes: Any): ...
    def perform_rollover(self) -> None: ...
    def emit(self, record: Any) -> None: ...

class TimedRotatingFileHandler(FileHandler):
    date_format: Any = ...
    backup_count: Any = ...
    rollover_format: Any = ...
    original_filename: Any = ...
    timed_filename_for_current: Any = ...
    def __init__(
        self,
        filename: Any,
        mode: str = ...,
        encoding: str = ...,
        level: Any = ...,
        format_string: Optional[Any] = ...,
        date_format: str = ...,
        backup_count: int = ...,
        filter: Optional[Any] = ...,
        bubble: bool = ...,
        timed_filename_for_current: bool = ...,
        rollover_format: str = ...,
    ) -> None: ...
    def generate_timed_filename(self, timestamp: Any): ...
    def files_to_delete(self): ...
    def perform_rollover(self, new_timestamp: Any) -> None: ...
    def emit(self, record: Any) -> None: ...

class TestHandler(Handler, StringFormatterHandlerMixin):
    default_format_string: Any = ...
    records: Any = ...
    def __init__(
        self,
        level: Any = ...,
        format_string: Optional[Any] = ...,
        filter: Optional[Any] = ...,
        bubble: bool = ...,
        force_heavy_init: bool = ...,
    ) -> None: ...
    def close(self) -> None: ...
    def emit(self, record: Any) -> None: ...
    @property
    def formatted_records(self): ...
    @property
    def has_criticals(self): ...
    @property
    def has_errors(self): ...
    @property
    def has_warnings(self): ...
    @property
    def has_notices(self): ...
    @property
    def has_infos(self): ...
    @property
    def has_debugs(self): ...
    @property
    def has_traces(self): ...
    def has_critical(self, *args: Any, **kwargs: Any): ...
    def has_error(self, *args: Any, **kwargs: Any): ...
    def has_warning(self, *args: Any, **kwargs: Any): ...
    def has_notice(self, *args: Any, **kwargs: Any): ...
    def has_info(self, *args: Any, **kwargs: Any): ...
    def has_debug(self, *args: Any, **kwargs: Any): ...
    def has_trace(self, *args: Any, **kwargs: Any): ...

class MailHandler(Handler, StringFormatterHandlerMixin, LimitingHandlerMixin):
    default_format_string: Any = ...
    default_related_format_string: Any = ...
    default_subject: Any = ...
    max_record_cache: int = ...
    record_cache_prune: float = ...
    from_addr: Any = ...
    recipients: Any = ...
    subject: Any = ...
    server_addr: Any = ...
    credentials: Any = ...
    secure: Any = ...
    related_format_string: Any = ...
    starttls: Any = ...
    def __init__(
        self,
        from_addr: Any,
        recipients: Any,
        subject: Optional[Any] = ...,
        server_addr: Optional[Any] = ...,
        credentials: Optional[Any] = ...,
        secure: Optional[Any] = ...,
        record_limit: Optional[Any] = ...,
        record_delta: Optional[Any] = ...,
        level: Any = ...,
        format_string: Optional[Any] = ...,
        related_format_string: Optional[Any] = ...,
        filter: Optional[Any] = ...,
        bubble: bool = ...,
        starttls: bool = ...,
    ) -> None: ...
    def get_recipients(self, record: Any): ...
    def message_from_record(self, record: Any, suppressed: Any): ...
    def format_related_record(self, record: Any): ...
    def generate_mail(self, record: Any, suppressed: int = ...): ...
    def collapse_mails(self, mail: Any, related: Any, reason: Any): ...
    def get_connection(self): ...
    def close_connection(self, con: Any) -> None: ...
    def deliver(self, msg: Any, recipients: Any) -> None: ...
    def emit(self, record: Any) -> None: ...
    def emit_batch(self, records: Any, reason: Any) -> None: ...

class GMailHandler(MailHandler):
    def __init__(self, account_id: Any, password: Any, recipients: Any, **kw: Any) -> None: ...

class SyslogHandler(Handler, StringFormatterHandlerMixin):
    default_format_string: Any = ...
    LOG_EMERG: int = ...
    LOG_ALERT: int = ...
    LOG_CRIT: int = ...
    LOG_ERR: int = ...
    LOG_WARNING: int = ...
    LOG_NOTICE: int = ...
    LOG_INFO: int = ...
    LOG_DEBUG: int = ...
    LOG_KERN: int = ...
    LOG_USER: int = ...
    LOG_MAIL: int = ...
    LOG_DAEMON: int = ...
    LOG_AUTH: int = ...
    LOG_SYSLOG: int = ...
    LOG_LPR: int = ...
    LOG_NEWS: int = ...
    LOG_UUCP: int = ...
    LOG_CRON: int = ...
    LOG_AUTHPRIV: int = ...
    LOG_FTP: int = ...
    LOG_LOCAL0: int = ...
    LOG_LOCAL1: int = ...
    LOG_LOCAL2: int = ...
    LOG_LOCAL3: int = ...
    LOG_LOCAL4: int = ...
    LOG_LOCAL5: int = ...
    LOG_LOCAL6: int = ...
    LOG_LOCAL7: int = ...
    facility_names: Any = ...
    level_priority_map: Any = ...
    application_name: Any = ...
    remote_address: Any = ...
    facility: Any = ...
    socktype: Any = ...
    enveloper: Any = ...
    record_delimiter: Any = ...
    connection_exception: Any = ...
    def __init__(
        self,
        application_name: Optional[Any] = ...,
        address: Optional[Any] = ...,
        facility: str = ...,
        socktype: Any = ...,
        level: Any = ...,
        format_string: Optional[Any] = ...,
        filter: Optional[Any] = ...,
        bubble: bool = ...,
        record_delimiter: Optional[Any] = ...,
    ) -> None: ...
    def encode_priority(self, record: Any): ...
    def wrap_segments(self, record: Any, before: Any): ...
    def unix_envelope(self, record: Any): ...
    format_string: Any = ...
    def net_envelope(self, record: Any): ...
    def emit(self, record: Any) -> None: ...
    def send_to_socket(self, data: Any) -> None: ...
    def close(self) -> None: ...

class NTEventLogHandler(Handler, StringFormatterHandlerMixin):
    dllname: Any = ...
    default_format_string: Any = ...
    application_name: Any = ...
    log_type: Any = ...
    def __init__(
        self,
        application_name: Any,
        log_type: str = ...,
        level: Any = ...,
        format_string: Optional[Any] = ...,
        filter: Optional[Any] = ...,
        bubble: bool = ...,
    ) -> None: ...
    def unregister_logger(self) -> None: ...
    def get_event_type(self, record: Any): ...
    def get_event_category(self, record: Any): ...
    def get_message_id(self, record: Any): ...
    def emit(self, record: Any) -> None: ...

class FingersCrossedHandler(Handler):
    batch_emit_reason: str = ...
    lock: Any = ...
    buffered_records: Any = ...
    buffer_size: Any = ...
    def __init__(
        self,
        handler: Any,
        action_level: Any = ...,
        buffer_size: int = ...,
        pull_information: bool = ...,
        reset: bool = ...,
        filter: Optional[Any] = ...,
        bubble: bool = ...,
    ) -> None: ...
    def close(self) -> None: ...
    def enqueue(self, record: Any): ...
    def rollover(self, record: Any) -> None: ...
    @property
    def triggered(self): ...
    def emit(self, record: Any) -> None: ...

class GroupHandler(WrapperHandler):
    pull_information: Any = ...
    buffered_records: Any = ...
    def __init__(self, handler: Any, pull_information: bool = ...) -> None: ...
    def rollover(self) -> None: ...
    def pop_application(self) -> None: ...
    def pop_thread(self) -> None: ...
    def pop_context(self) -> None: ...
    def pop_greenlet(self) -> None: ...
    def emit(self, record: Any) -> None: ...
