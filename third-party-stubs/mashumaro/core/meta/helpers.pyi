import typing
from typing import Any

def get_type_origin(t: Any): ...
def get_generic_name(t: Any, short: bool = ...) -> str: ...
def get_args(t: typing.Any) -> typing.Tuple[typing.Any, ...]: ...
def get_literal_values(t: typing.Any) -> Any: ...
def type_name(
    t: typing.Any,
    short: bool = ...,
    type_vars: typing.Dict[str, typing.Any] = ...,
    is_type_origin: bool = ...,
    none_type_as_none: bool = ...,
) -> str: ...
def is_special_typing_primitive(t: Any) -> bool: ...
def is_generic(t: Any): ...
def is_typed_dict(t: Any) -> bool: ...
def is_named_tuple(t: Any) -> bool: ...
def is_new_type(t: Any) -> bool: ...
def is_union(t: Any): ...
def is_optional(t: Any, type_vars: typing.Dict[str, typing.Any] = ...) -> bool: ...
def is_annotated(t: Any) -> bool: ...
def is_literal(t: Any) -> bool: ...
def not_none_type_arg(
    args: typing.Tuple[typing.Any, ...], type_vars: typing.Dict[str, typing.Any] = ...
) -> Any: ...
def is_type_var(t: Any) -> bool: ...
def is_type_var_any(t: Any) -> bool: ...
def is_class_var(t: Any) -> bool: ...
def is_init_var(t: Any) -> bool: ...
def get_class_that_defines_method(method_name: Any, cls: Any): ...
def get_class_that_defines_field(field_name: Any, cls: Any): ...
def is_dataclass_dict_mixin(t: Any) -> bool: ...
def is_dataclass_dict_mixin_subclass(t: Any) -> bool: ...
def resolve_type_vars(cls, arg_types: Any = ..., is_cls_created: bool = ...): ...
def get_name_error_name(e: NameError) -> str: ...
def is_dialect_subclass(t: Any) -> bool: ...
